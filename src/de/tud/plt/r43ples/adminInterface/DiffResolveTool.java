package de.tud.plt.r43ples.adminInterface;
import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

import com.hp.hpl.jena.graph.Graph;
import com.hp.hpl.jena.graph.Node;
import com.hp.hpl.jena.graph.NodeFactory;
import com.hp.hpl.jena.graph.Triple;
import com.hp.hpl.jena.query.Query;
import com.hp.hpl.jena.query.QueryExecution;
import com.hp.hpl.jena.query.QueryExecutionFactory;
import com.hp.hpl.jena.query.QueryFactory;
import com.hp.hpl.jena.query.QuerySolution;
import com.hp.hpl.jena.query.ResultSet;
import com.hp.hpl.jena.rdf.model.Model;
import com.hp.hpl.jena.rdf.model.ModelFactory;

/**
 * The diff and resolve tool. Provides methods for merging.
 * 
 * @author Stephan Hensel
 *
 */
public class DiffResolveTool {

	/** The structure */
	private static Structure structure = null;

	
	/**
	 * Checks element for differences.
	 * 
	 * @param element the element to check for differences
	 * @param diffResult the diff result generated by checkForDifferences()
	 * @return boolean
	 */
	public boolean differenceInElement(String element, HashMap<String, Differences> diffResult) {
		Differences differences = diffResult.get(element);
		//something added or removed -> return true
		if ((!differences.getAdded().isEmpty()) || (!differences.getRemoved().isEmpty())) {
			return true;
		} else {
			//check sub elements
			Iterator<Node> ite = differences.getDifferences().keySet().iterator();
			while (ite.hasNext()) {
				Node next = ite.next();
				if (!differences.getDifferences().get(next).isEmpty()) {
					return true;
				}
			}
		}
		
		return false;
	}
	
	
	/**
	 * Checks specific element for differences.
	 * 
	 * @param element the element
	 * @param specificElement the element to check for differences
	 * @param diffResult the diff result generated by checkForDifferences()
	 * @return boolean
	 */
	public boolean differenceInSpecificElement(String element, Node specificElement, HashMap<String, Differences> diffResult) {
		Differences differences = diffResult.get(element);
		//check array list for differences
		ArrayList<Node> list = differences.getDifferences().get(specificElement);
		if (!list.isEmpty()) {
			return true;
		}
		
		return false;
	}
	
	
	/**
	 * Checks whole data for differences.
	 * 
	 * @param diffResult the diff result generated by checkForDifferences()
	 * @return boolean
	 */
	public boolean differenceInAllElements(HashMap<String, Differences> diffResult) {
		//check all elements for differences
		Iterator<String> ite = diffResult.keySet().iterator();
		while (ite.hasNext()) {
			String next = ite.next();
			if (differenceInElement(next, diffResult)) {
				return true;
			}
		}
		
		return false;
	}
	
	
	/**
	 * Lists all elements with differences.
	 * 
	 * @param diffResult the diff result generated by checkForDifferences()
	 * @return list with all elements which are different
	 */
	public ArrayList<String> listAllElementsWithDifferences(HashMap<String, Differences> diffResult) {
		ArrayList<String> list = new ArrayList<String>();
		//check all elements for differences and add elements with differences to result list
		Iterator<String> ite = diffResult.keySet().iterator();
		while (ite.hasNext()) {
			String next = ite.next();
			if (differenceInElement(next, diffResult)) {
				list.add(next);
			}
		}
		
		return list;
	}
	
	
	/**
	 * Lists all specific elements with differences.
	 * 
	 * @param element the element
	 * @param diffResult the diff result generated by checkForDifferences()
	 * @return list with all specific elements which are different
	 */
	public static ArrayList<Node> listAllSpecificElementsWithDifferences(String element, HashMap<String, Differences> diffResult) {
		System.out.println("Test: " + element);
		ArrayList<Node> list = new ArrayList<Node>();
		//check element for differences and add specific elements with differences to result list
		Iterator<Node> ite = diffResult.get(element).getDifferences().keySet().iterator();
		while (ite.hasNext()) {
			Node next = ite.next();
			if (!diffResult.get(element).getDifferences().get(next).isEmpty()) {
				list.add(next);
			}
		}
		
		return list;
	}
	
	
	/**
	 * Lists all sub elements with differences.
	 * 
	 * @param element the element
	 * @param node the specific element
	 * @param diffResult the diff result generated by checkForDifferences()
	 * @return list with all sub elements which are different
	 */
	public static ArrayList<Node> getAllDifferencesOfSpecificElement(String element, Node node, HashMap<String, Differences> diffResult) {		
		return diffResult.get(element).getDifferences().get(node);
	}
	
	
	/**
	 * Get all added specific elements.
	 * 
	 * @param element the element
	 * @param diffResult the diff result generated by checkForDifferences()
	 * @return list with all added specific elements
	 */
	public static ArrayList<Node> getAllAddedSpecificElements(String element, HashMap<String, Differences> diffResult) {
		return diffResult.get(element).getAdded();
	}
	
	
	/**
	 * Get all removed specific elements.
	 * 
	 * @param element the element
	 * @param diffResult the diff result generated by checkForDifferences()
	 * @return list with all removed specific elements
	 */
	public static ArrayList<Node> getAllRemovedSpecificElements(String element, HashMap<String, Differences> diffResult) {
		return diffResult.get(element).getRemoved();
	}
	
	
	/**
	 * Get all specific elements which are in both.
	 * 
	 * @param element the element
	 * @param diffResult the diff result generated by checkForDifferences()
	 * @return list with all specific elements which are in both
	 */
	public static ArrayList<Node> getAllSameSpecificElements(String element, HashMap<String, Differences> diffResult) {
		return diffResult.get(element).getSame();
	}
	
	
	/**
	 * Returns a map with 2 entries.
	 * keys: new_values and old_values; values: array list with all different values
	 * 
	 * @param specificElement the specific element
	 * @param subElement the sub element
	 * @param graphNew the new graph
	 * @param graphOld the old graph
	 * @return map with the 2 entries new_values and old_values
	 */
	public HashMap<String, ArrayList<Node>> showDifference(Node specificElement, Node subElement, Model graphNew, Model graphOld) {
		//result map with 2 entries (new_values, old_values)
		HashMap<String, ArrayList<Node>> map = new HashMap<String, ArrayList<Node>>();
		
		//create query
		String queryString =	"SELECT ?o " +
								"WHERE {<" + specificElement + "> <" + subElement + "> ?o}";
		
		Query query = QueryFactory.create(queryString);
		
		// query execution NEW
		QueryExecution qeNew = QueryExecutionFactory.create(query, graphNew);
		
		ResultSet resultsNew = qeNew.execSelect();
		
		ArrayList<Node> listNew = new ArrayList<Node>(); 
		
	    while(resultsNew.hasNext()) {
	    	QuerySolution qsNew = resultsNew.next();
	    	Node valueNew = null;
	    	// get value
	    	try {
	    		valueNew = NodeFactory.createLiteral(qsNew.getLiteral("?o").getValue().toString());
			} catch (ClassCastException e) {
				valueNew = NodeFactory.createURI(qsNew.getResource("?o").toString());
			}

	    	listNew.add(valueNew);
	    }
	    
	    map.put("new_values", listNew);
	    
	    
		// query execution OLD
		QueryExecution qeOld = QueryExecutionFactory.create(query, graphOld);
		
		ResultSet resultsOld = qeOld.execSelect();
		
		ArrayList<Node> listOld = new ArrayList<Node>(); 
		
	    while(resultsOld.hasNext()) {
	    	QuerySolution qsOld = resultsOld.next();
	    	Node valueOld = null;
	    	// get value
	    	try {
	    		valueOld = NodeFactory.createLiteral(qsOld.getLiteral("?o").getValue().toString());
			} catch (ClassCastException e) {
				valueOld = NodeFactory.createURI(qsOld.getResource("?o").toString());
			}

	    	listOld.add(valueOld);
	    }
	    
	    map.put("old_values", listOld);
		
		return map;
	}
	
	
	/**
	 * Returns a map with 2 entries.
	 * keys: new_model and old_model; values: updated models 
	 * 
	 * @param specificElement the specific element
	 * @param subElement the sub element
	 * @param graphNew the new graph
	 * @param graphOld the old graph
	 * @param showDiff the generated difference (by showDifference())
	 * @param selectNew if true then the new value is added to elsewhere the old
	 * @return map with the 2 entries new_model and old_model
	 */
	public HashMap<String, Model> selectDifference(Node specificElement, Node subElement, Model graphNew, Model graphOld, HashMap<String, ArrayList<Node>> showDiff, boolean selectNew) {
		//result map with 2 entries (new_model, old_model)
		HashMap<String, Model> map = new HashMap<String, Model>();
		
		ArrayList<Node> newValues = showDiff.get("new_values");
		ArrayList<Node> oldValues = showDiff.get("old_values");

		Graph newG = graphNew.getGraph();
		Graph oldG = graphOld.getGraph();

		if (selectNew == true) {
			//DELETE oldValues from graphOld
			//INSERT newValues into graphOld
			
			Iterator<Node> oldValuesIte = oldValues.iterator();
			while (oldValuesIte.hasNext()) {
				Node oldValue = oldValuesIte.next();
				
				Node s = specificElement;
				Node p = subElement;
				Node o = oldValue;
				
				Triple triple = new Triple(s, p, o);

				oldG.delete(triple);
			}
			
			Iterator<Node> newValuesIte = newValues.iterator();
			while (newValuesIte.hasNext()) {
				Node newValue = newValuesIte.next();
				
				Node s = specificElement;
				Node p = subElement;
				Node o = newValue;
				
				Triple triple = new Triple(s, p, o);

				oldG.add(triple);
			}

		} else {
			//DELETE newValues from graphNew
			//INSERT oldValues into graphNew
			
			Iterator<Node> newValuesIte = newValues.iterator();
			while (newValuesIte.hasNext()) {
				Node newValue = newValuesIte.next();
				
				Node s = specificElement;
				Node p = subElement;
				Node o = newValue;
				
				Triple triple = new Triple(s, p, o);

				newG.delete(triple);
			}
			
			Iterator<Node> oldValuesIte = oldValues.iterator();
			while (oldValuesIte.hasNext()) {
				Node oldValue = oldValuesIte.next();
				
				Node s = specificElement;
				Node p = subElement;
				Node o = oldValue;
				
				Triple triple = new Triple(s, p, o);

				newG.add(triple);
			}

		}

		graphNew = ModelFactory.createModelForGraph(newG);
		graphOld = ModelFactory.createModelForGraph(oldG);
		
		map.put("new_model", graphNew);
		map.put("old_model", graphOld);
		
		return map;
	}
	
	
	/**
	 * Returns a map with 2 entries.
	 * keys: new_model and old_model; values: updated models 
	 * 
	 * @param element the element
	 * @param specificElement the specific element
	 * @param graphNew the new graph
	 * @param graphOld the old graph
	 * @param selectNew if true then the new value is added to elsewhere the old
	 * @return map with the 2 entries new_model and old_model
	 */
	public HashMap<String, Model> acceptAdded(String element, Node specificElement, Model graphNew, Model graphOld, boolean selectNew) {
		//result map with 2 entries (new_model, old_model)
		HashMap<String, Model> map = new HashMap<String, Model>();
		
		Graph newG = graphNew.getGraph();
		Graph oldG = graphOld.getGraph();

		//get all sub elements
		Iterator<String> subElementsIte = structure.getClasses().get(element).getProperties().iterator();
		if (selectNew == true) {
			//add new data to graphOld
			
			//add node
			Triple tripleMain = new Triple(specificElement, NodeFactory.createURI("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), structure.getClasses().get(element).getUri());

			oldG.add(tripleMain);
			
			while (subElementsIte.hasNext()) {
				String nextName = subElementsIte.next();

				Node s = specificElement;
				Node p = NodeFactory.createURI(nextName);
				Node o = null;
				
				//create query
				String queryStringSame =	"SELECT ?o " +
											"WHERE {<" + s.toString() + "> <" + p.toString() + "> ?o }";
		
				Query query = QueryFactory.create(queryStringSame);
				
				//query execution on graphNew
				QueryExecution qe = QueryExecutionFactory.create(query, graphNew);
				
				ResultSet results = qe.execSelect();
				
				//get all sub element attributes
				while(results.hasNext()) {
					QuerySolution qs = results.next();
						
					// get name						
					try {
						o = NodeFactory.createLiteral(qs.getLiteral("?o").getValue().toString());
					} catch (ClassCastException e) {
						o = NodeFactory.createURI(qs.getResource("?o").toString());
					}
					
					//subElements.add(name);
					Triple triple = new Triple(s, p, o);

					oldG.add(triple);

				}
			}
		
		} else {
			//remove new data from graphNew
			
			//add node
			Triple tripleMain = new Triple(specificElement, NodeFactory.createURI("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), structure.getClasses().get(element).getUri());

			newG.delete(tripleMain);

			
			while (subElementsIte.hasNext()) {
				String nextName = subElementsIte.next();

				Node s = specificElement;
				Node p = NodeFactory.createURI(nextName);
				Node o = null;
				
				//create query
				String queryStringSame =	"SELECT ?o " +
											"WHERE {<" + s.toString() + "> <" + p.toString() + "> ?o }";
		
				Query query = QueryFactory.create(queryStringSame);
				
				//query execution on graphNew
				QueryExecution qe = QueryExecutionFactory.create(query, graphNew);
				
				ResultSet results = qe.execSelect();
				ArrayList<QuerySolution> resultsQs = new ArrayList<QuerySolution>();
				//create a copy elsewhere there is an error when executing (ConcurrentModificationException)
				while(results.hasNext()) {
					QuerySolution qs = results.next();
					resultsQs.add(qs);	
				}
				//get all sub element attributes
				Iterator<QuerySolution> qsIte = resultsQs.iterator();
				while(qsIte.hasNext()) {
					QuerySolution qs = qsIte.next();

					// get name						
					try {
						o = NodeFactory.createLiteral(qs.getLiteral("?o").getValue().toString());
					} catch (ClassCastException e) {
						o = NodeFactory.createURI(qs.getResource("?o").toString());
					}
					
					Triple triple = new Triple(s, p, o);

					newG.delete(triple);

				}
			}
		}
		
		graphNew = ModelFactory.createModelForGraph(newG);
		graphOld = ModelFactory.createModelForGraph(oldG);
		
		map.put("new_model", graphNew);
		map.put("old_model", graphOld);		
		
		return map;
	}
	
	
	/**
	 * Returns a map with 2 entries.
	 * keys: new_model and old_model; values: updated models 
	 * 
	 * @param element the element
	 * @param specificElement the specific element
	 * @param graphNew the new graph
	 * @param graphOld the old graph
	 * @param selectNew if true then the new value is added to elsewhere the old
	 * @return map with the 2 entries new_model and old_model
	 */
	public HashMap<String, Model> acceptRemoved(String element, Node specificElement, Model graphNew, Model graphOld, boolean selectNew) {
		//result map with 2 entries (new_model, old_model)
		HashMap<String, Model> map = new HashMap<String, Model>();
		
		Graph newG = graphNew.getGraph();
		Graph oldG = graphOld.getGraph();

		//get all sub elements
		Iterator<String> subElementsIte = structure.getClasses().get(element).getProperties().iterator();
		if (selectNew == true) {
			//remove new data from graphOld
			
			//remove node
			Triple tripleMain = new Triple(specificElement, NodeFactory.createURI("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), structure.getClasses().get(element).getUri());

			oldG.delete(tripleMain);
			
			while (subElementsIte.hasNext()) {
				String nextName = subElementsIte.next();

				Node s = specificElement;
				Node p = NodeFactory.createURI(nextName);
				Node o = null;
				
				//create query
				String queryStringSame =	"SELECT ?o " +
											"WHERE {<" + s.toString() + "> <" + p.toString() + "> ?o }";
		
				Query query = QueryFactory.create(queryStringSame);
				
				//query execution on graphNew
				QueryExecution qe = QueryExecutionFactory.create(query, graphNew);
				
				ResultSet results = qe.execSelect();
				
				//get all sub element attributes
				while(results.hasNext()) {
					QuerySolution qs = results.next();
						
					// get name						
					try {
						o = NodeFactory.createLiteral(qs.getLiteral("?o").getValue().toString());
					} catch (ClassCastException e) {
						o = NodeFactory.createURI(qs.getResource("?o").toString());
					}
					

					Triple triple = new Triple(s, p, o);

					oldG.delete(triple);

				}
			}
		
		} else {
			//add new data from graphNew
			
			//add node
			Triple tripleMain = new Triple(specificElement, NodeFactory.createURI("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), structure.getClasses().get(element).getUri());

			newG.add(tripleMain);

			
			while (subElementsIte.hasNext()) {
				String nextName = subElementsIte.next();

				Node s = specificElement;
				Node p = NodeFactory.createURI(nextName);
				Node o = null;
				
				//create query
				String queryStringSame =	"SELECT ?o " +
											"WHERE {<" + s.toString() + "> <" + p.toString() + "> ?o }";
		
				Query query = QueryFactory.create(queryStringSame);
				
				//query execution on graphNew
				QueryExecution qe = QueryExecutionFactory.create(query, graphNew);
				
				ResultSet results = qe.execSelect();
				ArrayList<QuerySolution> resultsQs = new ArrayList<QuerySolution>();
				//create a copy elsewhere there is an error when executing (ConcurrentModificationException)
				while(results.hasNext()) {
					QuerySolution qs = results.next();
					resultsQs.add(qs);	
				}
				//get all sub element attributes
				Iterator<QuerySolution> qsIte = resultsQs.iterator();
				while(qsIte.hasNext()) {
					QuerySolution qs = qsIte.next();

					// get name						
					try {
						o = NodeFactory.createLiteral(qs.getLiteral("?o").getValue().toString());
					} catch (ClassCastException e) {
						o = NodeFactory.createURI(qs.getResource("?o").toString());
					}
					
					Triple triple = new Triple(s, p, o);

					newG.add(triple);

				}
			}
		}
		
		graphNew = ModelFactory.createModelForGraph(newG);
		graphOld = ModelFactory.createModelForGraph(oldG);
		
		map.put("new_model", graphNew);
		map.put("old_model", graphOld);		
		
		return map;
	}
	
	
	/**
	 * Check graphs for differences.
	 * 
	 * @param graphNew new Graph
	 * @param graphOld old Graph
	 * @return diff result
	 */
	public HashMap<String, Differences> checkForDifferences(Model graphNew, Model graphOld) {
		
		//diff results
		HashMap<String, Differences> diffResult = new HashMap<String, Differences>();
		
		Iterator<String> allElementsIte = structure.getClasses().keySet().iterator();
		while (allElementsIte.hasNext()) {
			StructureClass sElement = structure.getClasses().get(allElementsIte.next());
			
			
			//create differences map for element
			HashMap<Node, ArrayList<Node>> differences = new HashMap<Node, ArrayList<Node>>();
			
			//create query
			String queryString =	"SELECT ?s " +
									"WHERE {?s a <" + sElement.getUri() + ">}";
			
			Query query = QueryFactory.create(queryString);
			
			// query execution NEW
			QueryExecution qeNew = QueryExecutionFactory.create(query, graphNew);
			
			ResultSet resultsNew = qeNew.execSelect();
			
			ArrayList<Node> listNew = new ArrayList<Node>(); 
			
		    while(resultsNew.hasNext()) {
		    	QuerySolution qsNew = resultsNew.next();
		    	Node uriNew = null;
		    	// get uri of element
		    	uriNew = NodeFactory.createURI(qsNew.getResource("?s").toString());
		    	listNew.add(uriNew);
		    }
		    
		    // query execution OLD
 			QueryExecution qeOld = QueryExecutionFactory.create(query, graphOld);
 			
 			ResultSet resultsOld = qeOld.execSelect();
 			
 			ArrayList<Node> listOld = new ArrayList<Node>(); 
 			
 		    while(resultsOld.hasNext()) {
 		    	QuerySolution qsOld = resultsOld.next();
 		    	Node uriOld = null;
 		    	// get uri of element
 		    	uriOld = NodeFactory.createURI(qsOld.getResource("?s").toString());
 		    	listOld.add(uriOld);
 		    }
 		    
 		    //generate intersections
 		    
 		    //added
 		    @SuppressWarnings("unchecked")
			ArrayList<Node> added = (ArrayList<Node>) listNew.clone();
 		    added.removeAll(listOld);
 		    
 		    //removed
 		    @SuppressWarnings("unchecked")
			ArrayList<Node> removed = (ArrayList<Node>) listOld.clone();
		    removed.removeAll(listNew);
		    
		    //same
		    @SuppressWarnings("unchecked")
			ArrayList<Node> same = (ArrayList<Node>) listNew.clone();
		    same.retainAll(listOld);
 		    
		    
		    //check all sub elements of elements in same
		    Iterator<Node> sameIte = same.iterator();
		    while (sameIte.hasNext()) {
		    	Node sameUriNext = sameIte.next();
		    	
		    	//add all sub elements with differences to the list
		    	ArrayList<Node> difference = new ArrayList<Node>();
		    	
		    	Iterator<String> subElementsIte = sElement.getProperties().iterator();
		    	while (subElementsIte.hasNext()) {
		    		String subElementsName = subElementsIte.next();
		    		
		    		//create query
		    		String queryStringSame =	"SELECT ?o " +
		    									"WHERE {<" + sameUriNext.toString() + "> <" + subElementsName + "> ?o }";

		    		Query querySame = QueryFactory.create(queryStringSame);
		    		
		    		//query execution on graphNew
					QueryExecution qeSameNew = QueryExecutionFactory.create(querySame, graphNew);
					
					ResultSet resultsSameNew = qeSameNew.execSelect();
					
					ArrayList<Node> checkSubElementsNew = new ArrayList<Node>();
					
					//get all sub element attributes
					while(resultsSameNew.hasNext()) {
						QuerySolution qsSameNew = resultsSameNew.next();
						Node nameNew = null;
							
						// get name						
						try {
							nameNew = NodeFactory.createLiteral(qsSameNew.getLiteral("?o").getValue().toString());
						} catch (ClassCastException e) {
							nameNew = NodeFactory.createURI(qsSameNew.getResource("?o").toString());
						}
						
						checkSubElementsNew.add(nameNew);
					}
					
					
					//query execution on graphOld
					QueryExecution qeSameOld = QueryExecutionFactory.create(querySame, graphOld);
					
					ResultSet resultsSameOld = qeSameOld.execSelect();
					
					ArrayList<Node> checkSubElementsOld = new ArrayList<Node>();
					
					//get all sub element attributes
					while(resultsSameOld.hasNext()) {
						QuerySolution qsSameOld = resultsSameOld.next();
						Node nameOld = null;
							
						// get name
						try {
							nameOld = NodeFactory.createLiteral(qsSameOld.getLiteral("?o").getValue().toString());
						} catch (ClassCastException e) {
							nameOld = NodeFactory.createURI(qsSameOld.getResource("?o").toString());
						}
						
						checkSubElementsOld.add(nameOld);
					}

					//to check for differences
					@SuppressWarnings("unchecked")
					ArrayList<Node> differenceList = (ArrayList<Node>) checkSubElementsNew.clone();
					
					differenceList.removeAll(checkSubElementsOld);

					if (!differenceList.isEmpty()) {
						//there is a difference
						difference.add(NodeFactory.createURI(subElementsName));
						
					}
		    		
		    	}
		    	
		    	differences.put(sameUriNext, difference);

		    }
		    
		    //create diff results
		    diffResult.put(sElement.getUri().toString()/**getLabel()**/, new Differences(added, removed, same, differences));
		}
		
		return diffResult;
		
	}
	
	
	/**
	 * Generates the structure of the ontology in java classes.
	 * 
	 * @param ontology the ontology
	 * @param name the name
	 */
	public void generateStructureModelFromOntology(Model ontology, String name) { 
		
		//hash map to store all classes
		HashMap<String, StructureClass> classes = new HashMap<String, StructureClass>();
		
		//get all classes
		//create query
		String queryStringClasses =	"SELECT ?uri " +
									"WHERE {" +
									"?uri <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://www.w3.org/2002/07/owl#Class> . " +
									" }";
		
		Query queryClasses = QueryFactory.create(queryStringClasses);
		
		//query execution on ontology
		QueryExecution qeClasses = QueryExecutionFactory.create(queryClasses, ontology);
		
		ResultSet resultsClasses = qeClasses.execSelect();
		
		//iterate through all classes
		while(resultsClasses.hasNext()) {
			QuerySolution qsClasses = resultsClasses.next();
			String stringClassesUri = qsClasses.getResource("?uri").toString();
			
			//get class properties
			//create query
			String queryStringClass =	"SELECT ?label " +
										"WHERE {" +
										"<" + stringClassesUri + "> <http://www.w3.org/2000/01/rdf-schema#label> ?label . " +
									    "FILTER (LANG(?label) = 'en') . " +
										"}";
			
			Query queryClass = QueryFactory.create(queryStringClass);
			
			//query execution on ontology
			QueryExecution qeClass = QueryExecutionFactory.create(queryClass, ontology);
			
			ResultSet resultsClass = qeClass.execSelect();
			
			//get all properties of class
			//create query
			String queryStringClassProperties =	"SELECT ?uri " +
												"WHERE {" +
												"?uri <http://www.w3.org/2000/01/rdf-schema#domain> <" + stringClassesUri + "> " +
												"}";
			
			Query queryClassProperties = QueryFactory.create(queryStringClassProperties);
			
			//query execution on ontology
			QueryExecution qeClassProperties = QueryExecutionFactory.create(queryClassProperties, ontology);
			
			ResultSet resultsClassProperties = qeClassProperties.execSelect();
			
			//store all properties in array list
			ArrayList<String> propertiesStore = new ArrayList<String>();
			
			while(resultsClassProperties.hasNext()) {
				QuerySolution qsClassProperties = resultsClassProperties.next();
				String stringClassProperties = qsClassProperties.getResource("?uri").toString();
				propertiesStore.add(stringClassProperties);
			}

			//create structure of current class
			StructureClass structureClass = new StructureClass(resultsClass.next().getLiteral("?label").getValue().toString(), NodeFactory.createURI(stringClassesUri), propertiesStore);
			//add current class to structure classes
			classes.put(stringClassesUri, structureClass);
		}
		
		//#################################################################################################################################################################################
		
		//hash map to store all properties
		HashMap<String, StructureProperty> properties = new HashMap<String, StructureProperty>();
		
		//get all properties
		//create query
		String queryStringProperties =	"SELECT ?uri " +
										"WHERE {" +
										"{?uri <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://www.w3.org/2002/07/owl#ObjectProperty> . }" +
										"UNION" +
										"{?uri <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://www.w3.org/2002/07/owl#DatatypeProperty> . }" +
										" }";
		
		Query queryProperties = QueryFactory.create(queryStringProperties);
		
		//query execution on ontology
		QueryExecution qeProperties = QueryExecutionFactory.create(queryProperties, ontology);
		
		ResultSet resultsProperties = qeProperties.execSelect();
		
		//iterate through all properties
		while(resultsProperties.hasNext()) {
			QuerySolution qsProperties = resultsProperties.next();
			String stringPropertiesUri = qsProperties.getResource("?uri").toString();
			
			//get all properties of property
			//create query
			String queryStringProperty =	"SELECT ?type ?label ?range " +
											"WHERE {" +
											"<" + stringPropertiesUri + "> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> ?type . " +
											"<" + stringPropertiesUri + "> <http://www.w3.org/2000/01/rdf-schema#label> ?label . " +
											"<" + stringPropertiesUri + "> <http://www.w3.org/2000/01/rdf-schema#range> ?range . " +
											"FILTER (LANG(?label) = 'en') . " +
											"}";
			
			Query queryProperty = QueryFactory.create(queryStringProperty);
			
			//query execution on ontology
			QueryExecution qeProperty = QueryExecutionFactory.create(queryProperty, ontology);
			
			ResultSet resultsProperty = qeProperty.execSelect();
			
			QuerySolution qsProperty = resultsProperty.next();
			
			StructureProperty structProperty = new StructureProperty(qsProperty.getResource("?type").toString(), qsProperty.getLiteral("?label").getValue().toString(), NodeFactory.createURI(stringPropertiesUri), qsProperty.getResource("?range").toString());
			//add current property to structure properties
			properties.put(stringPropertiesUri, structProperty);
		}
		
		structure = new Structure(name, classes, properties);
		
	}
	
	
	/**
	 * Read file to jena model.
	 * 
	 * @param path the file path
	 * @return the model
	 * @throws IOException
	 */
	public Model readFile(String path) throws IOException {
		Model model = null;
		model = ModelFactory.createDefaultModel();
		InputStream is = new BufferedInputStream(new FileInputStream(path));
		model.read(is, null, "TURTLE");
		is.close();
		
		return model;
	}
	

	/**
	 * Get the structure.
	 * 
	 * @return structure
	 */
	public Structure getStructure() {
		return structure;
	}

}